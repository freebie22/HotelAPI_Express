# Звіт з модульної роботи №1
# Виконав студент групи Б-121-22-5-ПІ - Бойков А.Д.
# Проєкт №2
## Розробка REST API для бронювання готелів

# 1. Модель якості

## Модель якості згідно з ISO/IEC 25010

# Атрибути якості REST API

| **Характеристика**           | **Підхарактеристика**                     | **Опис**                                                                                     | **Пріоритет** |
|-----------------------------|------------------------------------------|---------------------------------------------------------------------------------------------|--------------|
| **Функціональна придатність** | **Коректність обробки бронювань**         | API має правильно обробляти запити на створення, зміну та скасування бронювання, уникаючи дублювань і конфліктів у розкладі | Високий      |
|                             | **Актуальність даних**                     | Дані про доступність мають оновлюватися в реальному часі, щоб запобігти ситуаціям подвійного бронювання | Високий      |
| **Продуктивність (ефективність)** | **Час відповіді API**                     | API має швидко обробляти запити без значних затримок, забезпечуючи низький час відгуку навіть при пікових навантаженнях | Високий      |
|                             | **Масштабованість**                        | API повинен ефективно працювати при високих навантаженнях, підтримуючи горизонтальне масштабування та балансування навантаження | Середній     |
| **Зручність використання**   | **Простота інтеграції**                    | API повинен мати зрозумілу документацію, SDK або приклади запитів, а також підтримувати стандартні формати запитів (REST, GraphQL) | Високий      |
|                             | **Узгодженість відповіді**                 | Формат даних у відповідях має бути уніфікований (наприклад, JSON, XML) і відповідати узгодженим схемам та стандартам API | Високий      |
| **Безпека**                 | **Авторизація та автентифікація**           | Доступ до API має бути захищеним (OAuth, JWT) з можливістю використання ролей і дозволів для контролю доступу | Високий      |
|                             | **Захист від несанкціонованих запитів**     | API має мати механізми захисту від DDoS-атак, SQL-ін’єкцій, XSS, а також обмеження запитів (rate limiting) | Високий      |
| **Надійність**              | **Стійкість до збоїв**                     | API має залишатися працездатним у разі збоїв окремих компонентів, забезпечуючи автоматичне відновлення або резервне копіювання | Високий      |
|                             | **Відновлення після помилок**              | У разі невдалої операції API має повертати коректні коди помилок, логи для діагностики та рекомендації щодо подальших дій | Високий      |

# 2. Вибір метрик та їх обґрунтування

| Характеристика               | Метрика                           | Опис метрики                                                     | Формула/Значення |
|------------------------------|----------------------------------|----------------------------------------------------------------|------------------|
| Функціональна придатність    | Відсоток успішних запитів        | Співвідношення успішних операцій бронювання до загальної кількості | `(Успішні запити / Всі запити) × 100%` |
| Продуктивність (ефективність) | Час відповіді API               | Середній час відповіді API на запит                              | `Σ(Час відповіді) / Кількість запитів` |
|                              | Пропускна здатність             | Кількість запитів, які API може обробити за секунду             | `Кількість запитів / Час` |
| Зручність використання       | Час інтеграції API              | Середній час, необхідний для підключення API до іншої системи   | `Σ(Час інтеграції) / Кількість інтеграцій` |
|                              | Відсоток успішних парсингів     | Частка відповідей API, які успішно парсяться без помилок        | `(Успішні парсинги / Всі відповіді) × 100%` |
| Безпека                      | Кількість спроб несанкціонованого доступу | Виявлені спроби отримання несанкціонованого доступу до API | `Кількість спроб` |
|                              | Виконання безпеки               | Частка успішних перевірок автентифікації                         | `(Успішні автентифікації / Всі спроби) × 100%` |
| Надійність                   | Час безвідмовної роботи          | Період безперервної роботи API без збоїв                         | `MTBF = Σ(Час роботи) / Кількість збоїв` |
|                              | Середній час відновлення        | Час, необхідний для відновлення роботи після збою               | `MTTR = Σ(Час відновлення) / Кількість збоїв` |

# 3. Формальна верифікація специфікацій

### Специфікація обмежень для REST API
- Кімната не може бути заброньована двічі на один і той самий період різними гостями.
- Період повинен бути дійсним.
- Клієнт повинен мати змогу здійснити бронювання кімнати на певний період.

### Перевірка обмежень у Alloy
```alloy
module HotelBooking

-- Визначення об'єктів
sig Client {}

sig Room {
    bookings: set Booking -- Бронювання для цієї кімнати
}

sig TimePeriod {
    start: one Int,         -- Початок періоду
    end: one Int            -- Кінець періоду
}

sig Booking {
    client: one Client,       -- Гість, який зробив бронювання
    room: one Room,         -- Кімната, яку забронювали
    period: one TimePeriod  -- Період бронювання
}

-- Обмеження: кімната не може бути заброньована двічі на один і той самий період різними гостями
fact NoDoubleBooking {
    all b1, b2: Booking |
        b1 != b2 and b1.room = b2.room and b1.period = b2.period and b1.client != b2.client
        -- Якщо дві броні мають однаковий період і ту саму кімнату, то гості повинні бути різними
        => b1.client != b2.client
}

-- Простий предикат для бронювання кімнати
pred bookRoom[c: Client, r: Room, s: Int, e: Int] {
    -- Перевірка, чи період є дійсним
    s < e
    -- Створення бронювання для гостя та кімнати
    some b: Booking | b.client = c and b.room = r and b.period.start = s and b.period.end = e
}

-- Тестовий предикат для виклику bookRoom
pred testBooking {
    some c: Client, r: Room, s, e: Int | {
        s < e
        bookRoom[c, r, s, e]
    }
}

-- Запуск тестового предикату
run testBooking for 3 Client, 3 Room, 5 Booking, 5 TimePeriod
```

### Alloy Analyzer
![image](https://github.com/user-attachments/assets/4878c065-93b0-4739-a656-1644a0369327)
#### Висновок: результат є правильним.
# 4. Верифікація моделей архітектури
## UML-діаграма сервісів та взаємодії між ними у PlantUML
```
@startuml

package "Controllers" {
    class BookingController {
        +createBooking()
        +getBookings()
        +getBooking(id: ObjectId)
        +updateBooking()
        +deleteBooking()
    }
    class ClientController {
        +createClient()
        +getClient(id: ObjectId)
        +signUp()
        +login()
        +deleteClient(id: ObjectId)
    }
    class HotelUsersController {
        +signUpHotelUser()
        +searchForUser()
        +loginUser()
        +getUsers()
    }
    class HotelController {
        +createHotel()
        +getHotel(id: ObjectId)
        +updateHotel()
        +deleteHotel()
    }
    class PaymentController {
        +processPayment()
        +confirmPayment()
        +cancelPayment()
        +getTransactions(clientId: ObjectId)
    }
    class RoomController {
        +createRoom()
        +getRooms()
        +getRoom(id: ObjectId)
        +checkAvailability()
        +updateRoom()
        +deleteRoom()
    }
}

package "Services" {
    class BookingService
    class ClientService
    class HotelService
    class PaymentService
    class RoomService
}

BookingController --> BookingService
ClientController --> ClientService
HotelUsersController --> HotelService
HotelController --> HotelService
PaymentController --> PaymentService
RoomController --> RoomService

BookingService --> PaymentService : "processPayment()"
BookingService --> RoomService : "checkAvailability()"
HotelService --> RoomService : "getRooms()"

@enduml
```
### UML-діграма в PlantUML
![image](https://github.com/user-attachments/assets/82629a6e-72ce-4eb0-9327-91469df66056)
# 5. SonarQube та GitHub Actions
## Налаштування та проходження тестів в SonarQube
![image](https://github.com/user-attachments/assets/8ecdde7a-f60d-4c57-b3d9-7eb0f5ac76ee)
## Успішне проходження тестів в поєднанні з GitHub Actions на прикладі файлу
![image](https://github.com/user-attachments/assets/399a71ee-a6f4-4b55-93b5-9e8cff36043e)
![image](https://github.com/user-attachments/assets/76336652-d25e-4d63-bd07-a9716a6c2c61)

